<!-- "doc" type, with tabs usage as template--><!-- Author: Kevin Cyu--><!-- include mixins--><!-- mixin - list--><!-- main--><!DOCTYPE html><html><!-- include header--><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Graph-Theory-Ch4</title><link rel="stylesheet" href="./asset/highlight.min.css"/><link rel="stylesheet" href="./asset/paper.min.css"/><link rel="stylesheet" href="./asset/monokai.css"/><link rel="stylesheet" href="./asset/main.css"/><link rel="stylesheet" href="./asset/cn-font.css"/><style>.tabs input[id=tab6]:checked~div[id=content6]{display:block}</style><style>.tabs input[id=tab7]:checked~div[id=content7]{display:block}</style><style>.tabs input[id=tab8]:checked~div[id=content8]{display:block}</style><style>.tabs input[id=tab9]:checked~div[id=content9]{display:block}</style><style>.tabs input[id=tab10]:checked~div[id=content10]{display:block}</style><style>.tabs input[id=tab11]:checked~div[id=content11]{display:block}</style><style>.tabs input[id=tab12]:checked~div[id=content12]{display:block}</style><style>.tabs input[id=tab13]:checked~div[id=content13]{display:block}</style><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="./asset/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="container"><div class="paper"><div class="demo-title" id="top"><div class="row flex-center"><div class="text-center"> <h1>Graph-Theory-Ch4</h1></div></div></div><div class="section"><div class="flex-spaces tabs">
<input id="tab1" type="radio" name="tabs" checked/>
<label for="tab1">01-basic</label>

<input id="tab2" type="radio" name="tabs"/>
<label for="tab2">02-hypercube</label>

<input id="tab3" type="radio" name="tabs"/>
<label for="tab3">03-HararyGraph</label>

<input id="tab4" type="radio" name="tabs"/>
<label for="tab4">04-simple-graph</label>

<input id="tab5" type="radio" name="tabs"/>
<label for="tab5">05-3-regular</label>

<input id="tab6" type="radio" name="tabs"/>
<label for="tab6">06-S以及S補集</label>

<input id="tab7" type="radio" name="tabs"/>
<label for="tab7">07-bond</label>

<input id="tab8" type="radio" name="tabs"/>
<label for="tab8">08-block-internal-disjoint</label>

<input id="tab9" type="radio" name="tabs"/>
<label for="tab9">09-Menger-Theorem</label>

<input id="tab10" type="radio" name="tabs"/>
<label for="tab10">10-Theorem-4-2-19</label>

<input id="tab11" type="radio" name="tabs"/>
<label for="tab11">11-Theorem-connectivity</label>

<input id="tab12" type="radio" name="tabs"/>
<label for="tab12">12-Theorem-ear</label>

<input id="tab13" type="radio" name="tabs"/>
<label for="tab13">13-Lemma-4-2-22</label>

<div class="content" id="content1"><p><h1>Basic</h1>
<ul>
<li>為第四章基礎部份，紀錄符號的使用</li>
</ul>
<h2>kappa ϰ(G) - Separating set</h2>
<p>唸做 kappa, 是為 <code>connectivity</code>，為 G 的最小 vertex 集合: <code>S</code> 的 size，其性質為 <code>G-S</code> 時會出現 disconnect 的現象，或是 <code>G-S</code> 只剩下 1 個 vertex（若 G 為 complete graph 時）</p>
<ul>
<li>也就是 S 的 size 剛好是在構成 disconnect 要素的 threshold 上！</li>
</ul>
<p>此時稱 graph G 為 <code>k-connected</code>，則表示其至少有值 = k 的 connectivity 存在！</p>
<ul>
<li>而 S 則稱為 G 的 <code>separating set</code>，或是 <code>vertex cut</code>，S ⊆ V(G)，且 <code>G-S</code> 會有多個 component 產生(e.g. <code>disconnect</code>)</li>
</ul>
<h3>ϰ(G) 性質</h3>
<ul>
<li>ϰ(Kn) = n-1 （Complete Graph）</li>
<li>ϰ(G) &lt;= n(G)-2 （當 G 不為 Complete Graph）</li>
<li>ϰ(Km,n) = min{m,n} （當 G 為 complete bipartite graph 時，取較小的 partite size 為 <code>ϰ</code> ）
<ul>
<li>ϰ(K3,3) = 3 : 表示其 graph 可為 1-connected, 2-connected, 3-connected</li>
</ul>
</li>
<li>當一個 graph 為 connected 且有 cut vertex，則其 &gt; 2 個 vertices 時，<code>connectivity</code> &gt; 1</li>
<li>若 graph &gt; 1 vertex 時，其 connectivity 卻為 0 時，表示其 graph <code>本身便是 disconnected</code> 狀態！</li>
<li>ϰ(K1) = 0 （本身為一個 vertex 的情形，=0）</li>
</ul>
<h2>N 維度的 HyperCube</h2>
<ul>
<li>記做 <code>Qn</code></li>
<li>vertex 數量為 <code>N=2^n</code></li>
<li>每個 vertex 上都以 <code>n 個 bits</code> 的二元字串來做表示 （也就解釋為何數量為 2^n）</li>
<li>每對鄰近的 vertices，兩兩之間只會有 <code>1 bit 不同</code></li>
<li><code>Qn</code> 為 bipartite graph</li>
</ul>
<pre><code>試證：
2 組 maximum matching 組合，其 edge 形成必為 even cycle
而 even cycle 則可以為 partite !
</code></pre>
<p><img src="./res/ch4-basic-hyperprove.jpg" alt=""></p>
<h3>HyperCube 增長維度方式</h3>
<p><img src="./res/ch4-basic-hyperdim.jpg" alt=""></p>
<h2>ϰ'(G) - Disconnecting set</h2>
<ul>
<li>
<p>disconnecting set:</p>
<ul>
<li>為 <code>edge set</code>（相比屬於 vertex 集合的 separating set）</li>
<li>標為 F (⊆ E(G))</li>
<li>使 G-F 有 &gt; 1 以上的 component (使 G <code>disconnect</code> 的 edge set)</li>
</ul>
</li>
<li>
<p>若一個 graph 其每個 disconnecting set 至少有 k 個 edges:</p>
<ul>
<li>則稱此 graph 為 <code>k-edge-connected</code></li>
</ul>
</li>
<li>
<p><code>edge-connectivity</code>: <code>ϰ'(G)</code>，為 G 最小數量的 disconnecting set</p>
</li>
</ul>
<h3>Def - [S,T]</h3>
<p><img src="./res/ch4-edge-cuts.jpg" alt=""></p>
<h3>Def - line graph</h3>
<ul>
<li>標記為 <code>L(G)</code>，表示為 graph G 的 line graph</li>
<li>用以做 graph 的轉換（ 原本的 edge 會對應到 line graph 中的 vertex ）</li>
<li>所以在後面 (<strong>Theorem 4-2-19</strong>) 的時候，就會用到 Line Graph 的這項性質！
<ul>
<li>並且在轉換時，會需要額外在端點加上偽 vertex，(讓原本端點 x,y 能夠搭配新加入的 vertex 形成 edge，並且轉換為 line graph 當中的 vertex )</li>
</ul>
</li>
</ul>
<h3>Def - ear</h3>
<ul>
<li>
<p><code>ear</code></p>
<ul>
<li>為 graph 中的 maximal path, 且其內部的 vertices 的 degree 皆為 2 (不包括<code>端點</code>)</li>
</ul>
</li>
<li>
<p><code>ear decomposition</code></p>
<ul>
<li>為 graph 中由一個 cycle <code>P0</code> 開始，依序加入 <code>P1</code>, <code>P2</code>, ..., <code>Pk</code>，當後續加入的 Pi (當 i &gt; 1) 對目前 graph 而言為 <code>ear</code>，則稱為 ear decomposition（<strong>e.g.</strong> if k=2, 若 P2 為 <code>ear</code> 的話，則 <code>P0 ∪ P1 ∪ P2</code> 稱為 ear decompostion ）</li>
</ul>
</li>
<li>
<p><code>closed ear</code></p>
<ul>
<li>為一 cycle C 於 graph G 當中，並且這個 C 上除了一個跟 G 相接的 vertex (i.e. 這個 cycle 的起點與終點也是這個 vertex!)之外，<em>其餘 vertex 的 degree 皆為 2</em></li>
</ul>
</li>
<li>
<p><code>closed-ear decomposition</code></p>
<ul>
<li>和 <code>ear decomposition</code> 相同，只不過在這邊 Pi(i &gt; 1) 可以是為 <strong>open ear 或是 closed ear</strong></li>
</ul>
</li>
<li>
<p>ear/closed-ear 皆有 theorem，參考 ear theorem 頁籤</p>
</li>
</ul>
</p></div><div class="content" id="content2"><p><h1>Prove kappa of hypercube</h1>
<ul>
<li>
<p>Figure 1
<img src="./res/ch4-basic-hyperkappa.jpg" alt=""></p>
</li>
<li>
<p>Figure 2
<img src="./res/ch4-basic-hyperkappa-2.jpg" alt=""></p>
</li>
</ul>
<h2>探討 Case 2</h2>
<ul>
<li>理解： 由於 Q 為 hypercube 型式，切分兩個 component 的 S 與 <code>其中一側做聯集</code> 的大小至少為 k-1 （在 case 中由於以數歸法，所以探討為 k-1 維度）</li>
<li>而 case 2 情況為扣除 S 之後，有一側會出現兩個 component；則可以知道，該側與 S 的聯集必定大於 k-1，形成 <code>聯集結果 &gt;= k</code> 的結果</li>
<li>總和必要性與充份性，證實 <code>k 維度的 hypercube 的 kappa 等於 k</code></li>
</ul>
</p></div><div class="content" id="content3"><p><h1>Harary Graph</h1>
<h2>Type</h2>
<ul>
<li>
<p>性質 + Type 1
<img src="./res/ch4-harary-1.jpg" alt=""></p>
</li>
<li>
<p>Type 2
<img src="./res/ch4-harary-2.jpg" alt=""></p>
</li>
<li>
<p>Type 2
<img src="./res/ch4-harary-3.jpg" alt=""></p>
</li>
</ul>
<h2>Theorem - Harary Graph 的 edge 數量</h2>
<p><img src="./res/ch4-harary-edges-1.jpg" alt=""></p>
<p><img src="./res/ch4-harary-edges-2.jpg" alt=""></p>
<p><img src="./res/ch4-harary-edges-3.jpg" alt=""></p>
</p></div><div class="content" id="content4"><p><h1>Theorem</h1>
<ul>
<li>在 simple graph 中，探討 ϰ(G), ϰ'(G), mini-degree 之間的關係</li>
</ul>
<p><img src="./res/ch4-thm-kappa-1.jpg" alt=""></p>
<p><img src="./res/ch4-thm-kappa-2.jpg" alt=""></p>
<p><img src="./res/ch4-thm-kappa-3.jpg" alt=""></p>
<p><img src="./res/ch4-thm-kappa-4.jpg" alt=""></p>
</p></div><div class="content" id="content5"><p><h1>Theorem: 3 regular graph</h1>
<ul>
<li>探討在 3-regular graph 情形下的狀況， <code>ϰ(G) = ϰ'(G)</code></li>
</ul>
<h2>Proof</h2>
<p><img src="./res/ch4-thm-3regular-1.jpg" alt=""></p>
<p><img src="./res/ch4-thm-3regular-2.jpg" alt=""></p>
</p></div><div class="content" id="content6"><p><h1>Proposition</h1>
<ul>
<li>探討 S 與 S的補集 間所有的 edges 數量</li>
</ul>
<p><img src="./res/ch4-count-edges.jpg" alt=""></p>
<h2>Corollary</h2>
<ul>
<li>
<p>若 G 為 simple graph 且 <code>|[S,S補集]| &lt; G 的 mini-degree</code>, S 不為空集合且屬於 G vertex set，則 <code>|S| &gt; G 的 mini-degree</code></p>
</li>
<li>
<p>Proof</p>
</li>
</ul>
<p><img src="./res/ch4-bond-proposition.jpg" alt=""></p>
<p><img src="./res/ch4-bond-proposition-2.jpg" alt=""></p>
</p></div><div class="content" id="content7"><p><h1>Def - <code>bond</code> 的定義</h1>
<p><code>bond</code> 為一最小的 <code>non-empty</code> edge cut
(e.g. =&gt; 為 cut-set, 並且其內部 <code>沒有任何其他的 proper subset 的 cut-set 存在</code>)</p>
<h2>Proposition</h2>
<p><img src="./res/ch4-bond-1.jpg" alt=""></p>
<p><img src="./res/ch4-bond-2.jpg" alt=""></p>
</p></div><div class="content" id="content8"><p><h1>k-connected</h1>
<h2>Def - block</h2>
<p><img src="./res/ch4-block.jpg" alt=""></p>
<h2>Def - internally-disjoint</h2>
<p><img src="./res/ch4-internal-disjoint.jpg" alt=""></p>
<h2>Theorem</h2>
<p><img src="./res/ch4-thm-internal-disjoint.jpg" alt=""></p>
<p><img src="./res/ch4-thm-internal-disjoint-2.jpg" alt=""></p>
<p><img src="./res/ch4-thm-internal-disjoint-3.jpg" alt=""></p>
<p><img src="./res/ch4-thm-internal-disjoint-4.jpg" alt=""></p>
<h2>Lemma</h2>
<p>當 G 為 <code>k-connected</code> graph，且 G' 是從 G 加上一個新的 vertex: y（並讓 y 擁有 k 個於 G 中的 vertex 做鄰居），則 G' 仍為 <code>k-connected</code></p>
<ul>
<li>Proof</li>
</ul>
<p><img src="./res/ch4-lemma-k-connected-1.jpg" alt=""></p>
<p><img src="./res/ch4-lemma-k-connected-2.jpg" alt=""></p>
</p></div><div class="content" id="content9"><p><h1>Theorem 4.2.17 - Menger Theorem</h1>
<h2>性質</h2>
<ul>
<li>兩點之間的 vertex cut 的最小值: <code>ϰ(x,y)</code>，會等於其內部 pairwise disjoint x,y path（內部<code>成對</code>、<code>不相交</code>，<code>不使用共同 vertex</code>的 paths ） 的數量最大值: <code>λ(x,y)</code></li>
</ul>
<p>=&gt; <code>ϰ(x,y) = λ(x,y)</code> by <em><strong>Menger 定理</strong></em></p>
<p><img src="./res/ch4-menger-1.jpg" alt=""></p>
<h2>Proof</h2>
<ul>
<li>證明主要透過<code>節點數量 n(G)</code>的狀況來做分析，並透過數學歸納法做證明</li>
</ul>
<p><img src="./res/ch4-menger-proof-1.jpg" alt=""></p>
<h3>Case 1</h3>
<p>Case 1 狀況為: 假設 x,y-cut: S 集合不為 x,y 的鄰居時的情況做分析</p>
<p><img src="./res/ch4-menger-proof-case1.jpg" alt=""></p>
<h4>Case 1-1</h4>
<p>藉由使得 x 側、 y 側收斂來說明，<code>|S| = k， ϰ(x',y) = ϰ(x,y') = k</code> (Case 1 中 <strong>connectivity</strong> 的部份)</p>
<p><img src="./res/ch4-menger-proof-case1-1.jpg" alt=""></p>
<h4>Case 1-2</h4>
<p>從收斂的兩張圖可以看出，<code>λ(x',y) = λ(x,y')</code>，進而可以刪除 x',y' 來還原成原圖，可得 <code>λ(x',y) = λ(x,y'), λ(x',y) = λ(x,y') = λ(x,y) = k</code>( Case 1 中 pairwise disjoint x,y path 的部份)</p>
<p><img src="./res/ch4-menger-proof-case1-2.jpg" alt=""></p>
<p>結合 Case 1-1 以及 Case 1-2，可以知道在 Case 1 假設情況下， <code>ϰ(x,y) = λ(x,y)</code>；接下來準備進入另一個狀況討論：</p>
<h3>Case 2 + Case 2-1</h3>
<p>當 x,y-cut: S 集合為 x,y 的鄰居時的情況：</p>
<p><code>Case 2-1:</code> 情況為 <strong>&quot;當 N(x), N(y) 之間還有存在其他 vertices 時&quot;</strong></p>
<p><img src="./res/ch4-menger-proof-case2.jpg" alt=""></p>
<h4>Case 2-2</h4>
<p><code>Case 2-2:</code> 情況為 <strong>&quot;當 N(x), N(y) 之中，有部份 overlap 情況發生時&quot;</strong></p>
<p><img src="./res/ch4-menger-proof-case2-2.jpg" alt=""></p>
<h4>Case 2-3</h4>
<p><code>Case 2-3:</code> 情況為 <strong>&quot;當 N(x), N(y) 互為 bipartite 之中的 partite set 時&quot;</strong></p>
<p><img src="./res/ch4-menger-proof-case2-3.jpg" alt=""></p>
<h3>Summary</h3>
<p>Case 2 則同樣透過這三種情況來說明 <code>&quot;ϰ(x,y) = λ(x,y)&quot;</code></p>
<p><img src="./res/ch4-menger-proof-case2-3-1.jpg" alt=""></p>
</p></div><div class="content" id="content10"><p><h1>Theorem 4.2.19</h1>
<ul>
<li>透過 <code>line graph</code> 性質來證明</li>
</ul>
<p><img src="./res/ch4-thm-4.2.19.jpg" alt=""></p>
<h2>Proof</h2>
<p><img src="./res/ch4-thm-4.2.19-proof.jpg" alt=""></p>
</p></div><div class="content" id="content11"><p><h1>Theorem</h1>
<p>計算 connectivity 以及 edge-connectivity ，以及 disjoint x,y-paths、 edge-disjoint x,y-paths 這兩對配對間大小</p>
<p>其中 <code>λ(x,y)</code> 為表示從 x 到 y 之間 pairwise 的 internally disjoint x,y-path 的數量 （ <code>λ'(x,y)</code> 則為 <strong>edge-disjoint x,y-paths set</strong> ）</p>
<p><img src="./res/ch4-thm-conn.jpg" alt=""></p>
<p><img src="./res/ch4-thm-conn-proof.jpg" alt=""></p>
<p><img src="./res/ch4-thm-conn-proof-1.jpg" alt=""></p>
</p></div><div class="content" id="content12"><p><p>這邊主要講述跟 ear 相關的幾個定理說明，包括 <code>ear</code>/<code>closed-ear</code>、<code>strong orientation</code></p>
<h2>Theorem - ear</h2>
<p>當一個 graph G 是為 <code>2-connected</code> 時，表示 G 有一個 <code>ear decomposition</code>; 並且每個 cycle 於 <code>2-connected</code> 的 graph 中皆為某個 <code>ear decomposition</code> 的 <strong>initial cycle</strong></p>
<ul>
<li>Proof:
<ul>
<li>先從 <code>Sufficiency</code> 證明起 （若 G 有 ear decomposition，則 graph 為 <code>2-connected</code>）</li>
<li>假設現在 graph G 為 2-connected, 則 G 滿足條件：能夠再加入任何一個 ear 後保持 2-connected 的狀態 -&gt;
<ul>
<li>設現有的 graph G 狀態為 2-connected (i.e. 擁有 ear decomposition)</li>
<li>則此時從上面找到兩點： u,v ，並且構成一個新的 ear : P (uv 間做 <code>subdivision</code> 的動作後，使得符合 ear 的定義：&quot;所有內部存在的 vertices ，其 degree 皆為 2&quot; 的條件)
<ul>
<li>subdivision 會保持 2-connected!</li>
</ul>
</li>
<li>G + uv 仍為 2-connected（於此適用於繼續以相同方式加入 ear! graph G <strong>仍會保持 2-connected</strong>）</li>
</ul>
</li>
<li>再來是 <code>Necessity</code> 的部份 （若 G 有 2-connected，則表示 G 有 ear decomposition）</li>
<li>假設目前存在一個 graph G，其為 2-connected； 且存在一個 Cycle <code>C</code> 於 G 當中</li>
<li>則此時從這個 cycle C 作為 ear decomposition 的 initial cycle 開始，逐一加入 ear 進去；做一個 iterative 的動作；
<ul>
<li>iterative 動作：</li>
<li>挑選非目前 ear decomposition 的兩個 vertices（<code>u,v</code>），再從 ear decomposition 上挑選兩個 vertices（<code>x,y</code>）</li>
<li>使這 4點 構成一個 cycle，這麼一來就形成新的 ear decomposition 了！</li>
</ul>
</li>
<li>停止條件為，<em>當目前的 ear decomposition</em> 等於當初的 graph G 時，就停止
<ul>
<li>所以當 iterative process 結束時，便可得到一個擁有 2-connected 性質的 ear decomposition - G</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Theorem - closed-ear</h2>
<p>當一個 graph G 是為 <code>2-edge-connected</code> 時，表示 G 有一個 <code>closed-ear decomposition</code>; 並且每個 cycle 於 <code>2-edge-connected</code> 的 graph 中皆為某個 <code>decomposition</code> 的 <strong>initial cycle</strong></p>
<p>（跟上面的定理類似，只是從原本針對 vertex 的 2-connected 換成 2-edge-connected）</p>
<h2>Theorem - strong orientation</h2>
<p>當 graph G 存在強方向性（該 graph 中所有的 undirected edge 全部替換成 directed 時稱之），則表示 G 為 <em><strong>2-edge-connected</strong></em>!</p>
<ul>
<li>Proof
<ul>
<li><code>Necessity</code>：
<ul>
<li>當 graph G 存在 strong orientation 時，表示 G 不可能為 disconnected、並且不存在 <code>cut-edge</code>!
( strongly orientation 的性質其中就有 <code>bridgeless</code>，所以不會存在兩個 component 之間只有單向的 directed edge 存在的情形 )</li>
</ul>
</li>
<li><code>Sufficiency</code>:
<ul>
<li>當 graph G 有 <code>2-edge-connected</code> 性質存在時，則其有一個 <code>closed-ear-decomposition</code> =&gt;</li>
<li>跟前面 ear 的定理證明類似，從 initial cycle 出發，把 initial cycle 上所有的 edge 做 orient，形成必要條件: strongly orientation</li>
<li>接著再一一加入<code>新的 ear</code>（跟前面的加入方式相同），並把這些新 ear 上面 edges 做 orient</li>
<li>藉此可以得證！</li>
</ul>
</li>
</ul>
</li>
</ul>
</p></div><div class="content" id="content13"><p><h2>Lemma 4.2.22</h2>
<p>主要證實性質： graph 在扣除<strong>一條</strong> edge 後，最多減少 1 個 connectivity !</p>
<p>=&gt; <strong>ϰ(G - xy) &lt;= ϰ(G)</strong>，透過指出兩種情況： <code>ϰ(G - xy) = ϰ(G)</code> 以及 <code>ϰ(G - xy) = ϰ(G) - 1</code> 來做說明</p>
<p><img src="./res/ch4-lemma-4-2-22.jpg" alt=""></p>
</p></div></div></div><div class="row flex-right"><p>Created by <span class="badge secondary">@ToolBuddy/@papercss</span></p></div></div></div></body></html>