<!DOCTYPE html>
<html>
  <head>
    <title>Hall&#x27;s Condition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-solarized-light.min.css"/>
  </head>
<body><h1 id="hall's-condition"><a class="header-link" href="#hall's-condition"></a>Hall&#39;s Condition</h1>
<p>一個 X,Y 的 bipartite graph G，擁有一個感染了所有 X partite set 內 vertices 的 Matching 的條件是必須符合 <code>| S | ≤ | N(S) |</code> ，S 屬於 X partite set ( N(S) 則屬於 Y partite set ) </p>
<h2 id="推導"><a class="header-link" href="#推導"></a>推導</h2>
<p>證明通常在條件的情況下，可以由正向（必要性）、及反向（充份性）來做推導的方向，並依據方向做後續的證明動作</p>
<h3 id="necessity（必要性）"><a class="header-link" href="#necessity（必要性）"></a>Necessity（必要性）</h3>
<p>從必要性著手來說是簡單的，我們可以用簡單的反證法來做說明：</p>
<ul class="list">
<li>若 |S| &gt; |N(S)| 的條件下，能夠感染所有的 X，則可以從對應的圖中看到，N(S) 的數量是不足以提供給 S 做一一對應</li>
</ul>
<h3 id="sufficiency（充份性）"><a class="header-link" href="#sufficiency（充份性）"></a>Sufficiency（充份性）</h3>
<p>再來就是比較複雜些的反向； 若 Hall condition 成立<code>（p）</code>，則 X,Y-bigraph 的 X 會全部被感染<code>（q）</code></p>
<p>而講義課本上的證明方式是利用上述反向再加上反向，透過笛摩根定律可以得到 <code>非 q 推導至 非 p</code> 這個結果，也是接下來討論主要依據</p>
<pre class="hljs"><code>變成：
當 M 為一個 G 內的 maximum matching，且 M 沒有完全感染 X partite <span class="hljs-built_in">set</span>，則一定存在屬於 X 的集合：S，並且 |<span class="hljs-type">N</span>(S)| <span class="hljs-type">&lt; |S</span>|

<span class="hljs-type">而我們現在便是用上述方式來做推導後，證實上面 "非 q</span> -&gt; 非 p<span class="hljs-string">" 為真即可！</span></code></pre><ul class="list">
<li>有了假設列式後，便可以開始推導：<ul class="list">
<li>u ∈ X： u 為一個沒有被 M 所感染的 vertex</li>
<li>定義集合： S 屬於 X， T 則屬於 Y， 兩者皆為<code>從 u 透過 M-alternating paths 可觸及</code>的 vertex 集合</li>
</ul>
</li>
<li>假設一個矛盾情況： graph G (X,Y) 沒有 matching 能夠感染所有 X 內的 vertices；讓 M 成為 G 的 maximum matching，且 u 表示為一個在 X partite set 中尚未被 matching M 感染的 vertex<ul class="list">
<li>再來設定準備討論的子集合：<em>從 u 開始能夠觸及的所有 alternating paths</em>（ matching / non-matching 相間 的 path ）</li>
<li>並在這個 paths 上的 vertices 集合做分類：<ul class="list">
<li>T：屬於 Y partite set </li>
<li>W：屬於 X partite set</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code>注意：
在這個矛盾假設 condition 下，這條 maximal alternating <span class="hljs-built_in">path</span> 的結束點是不會在 Y partite <span class="hljs-built_in">set</span> 中出現的！
不然會成為 augmenting <span class="hljs-built_in">path</span>！</code></pre><ul class="list">
<li>透過 M matching 的幫助下，除了 u 以外的 W 可以跟 T 互相配對；同樣的 T 內的 vertices 也透過 M 與 W \ {u} 互相配對</li>
<li><p>因此 M 提供了一個 W \ {u} 與 T 的 bijection， 並且 <code>|W| = |T| + 1</code></p>
<pre class="hljs"><code>W <span class="hljs-tag">\<span class="hljs-name"> </span><span class="hljs-string">{}</span></span> ： 表示除去 u 以外的 W 集合</code></pre></li>
<li><p>而另一方面， N_G(W)： W 集合在 G 中的鄰居之集合，其屬於 T 之中；</p>
</li>
<li>這時我們<code>假設 v 為 Y 中的 vertex，連接到 W 內的 vertex w 之上</code><ul class="list">
<li>若 (w,v) ∈ M，則 v 在 T 之中；</li>
<li>而這麼一來，我們便可以把原先的 alternating path (其 ending 於 W 中) 透過 v 這個 vertex 來做延伸</li>
</ul>
</li>
<li>那麼此時， <code>|N_G(W)| = |T| = |W| - 1</code> -&gt; 得證！</li>
</ul>
<pre class="hljs"><code>推導致此，可以導出 <span class="hljs-string">"不符合 Hall condition 的情況下，則 maximum matching 無法感染所有 X partite set 內 vertices"</span> 這一個論點</code></pre><h2 id="summary"><a class="header-link" href="#summary"></a>Summary</h2>
<ul class="list">
<li>簡單來說，充份性的部份我們透過 <strong>假設</strong> 上述的矛盾情況存在於 case 中，則這個 M alternating path 存在<ul class="list">
<li>使得 | N_G(W) | = | T |， 且 = |W| - 1</li>
<li>=&gt; | N_G(W) | = |W| - 1 &lt; | W | =&gt; <code>| N_G(W) | &lt; | W |</code></li>
</ul>
</li>
</ul>
<pre class="hljs"><code>得到 <span class="hljs-string">"不合 Hall's condition"</span> 的情況下，則其 maximum matching 無法感染所有 X partite <span class="hljs-keyword">set</span> 的結果！

（等價於前面提到的 <span class="hljs-string">"非 q -&gt; 非 p"</span>）</code></pre></body>
</html>
