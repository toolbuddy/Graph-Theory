<!DOCTYPE html>
<html>
  <head>
    <title>Tutte&#x27;s theorem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-solarized-light.min.css"/>
  </head>
<body><h1 id="tutte's-theorem"><a class="header-link" href="#tutte's-theorem"></a>Tutte&#39;s theorem</h1>
<p>由 Tutte 於 1947 年提出，理論為 <code>A graph G has a 1-factor iff o(G-S)&lt;=|S| for every S ⊆ V(G)</code>，而是理論也稱為該 graph G 的 <code>Tutte&#39;s Condition</code></p>
<ul class="list">
<li><code>o(G)</code>: 表示 graph G 的 odd components 的數量</li>
<li><code>1-factor</code>: 等於 perfact matching 的狀態</li>
<li><code>V(G)</code>: 表示 graph G 的 vertex 集合</li>
</ul>
<p>並且可以知道其幾項性質：</p>
<ul class="list">
<li>G 為一個 simple graph，vertex 數量記為 <code>n (e.g. = n(G))</code></li>
<li>o(G) ≡ n (mod 2), 指的是 o(G) 及 n(G) 同時為 even、或是同時為 odd<ul class="list">
<li>≡: &quot;定義&quot;、&quot;恆等於&quot;</li>
</ul>
</li>
<li>For S ⊆ V:<ul class="list">
<li>o(G-S) ≡ n(G-S) = n - |S| (mod 2)</li>
<li>|S| + o(G-S) ≡ n(G) (mod 2) <code>- 式(1)</code></li>
</ul>
</li>
<li>而從 Tutte condition 可得第2式： <ul class="list">
<li>∀S ⊂ V : <code>o(G − S) ≤ |S|</code>, <code>- 式(2)</code><ul class="list">
<li>∀: &quot;任意存在&quot;</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="證明與概念詳細解釋"><a class="header-link" href="#證明與概念詳細解釋"></a>證明與概念詳細解釋</h1>
<p>從正向（<code>Necessity</code>）與反向（<code>Sufficiency</code>）證明</p>
<h2 id="necessity（必要性）"><a class="header-link" href="#necessity（必要性）"></a>Necessity（必要性）</h2>
<ul class="list">
<li>正面從 G 是為一個 1-factor 的圖做解釋，可以知道以這種情況下可以畫出圖形：</li>
</ul>
<p class="img-container"><img src="../../../res/ch3/g-tutte-ne.png" alt=""></p>
<ul class="list">
<li>以性質來看<ul class="list">
<li>S 屬於 V(G)，而所有屬於 <code>G-S</code> 的 odd components 皆有一條 edge 連到 <code>S</code> 上</li>
<li>而連到 S 內，則表示在 S 中必有同等數目的 vertices 與這條 edge 做對應的 endpoint，且互為 unique（不會重複使用 endpoint）</li>
</ul>
</li>
<li>透過<strong>鴿籠原理</strong>，我們可以知道，以上圖為例，S 上有 3 個 odd components 與之連線，有 3 條 edges 進 S 當中，與之對應必有 3 個 unique 的 vertex，則 <code>|S| &gt;= o(G-S)</code> 這條式子必成立</li>
</ul>
<pre class="hljs"><code>從正面去證明是直觀，並且簡單的；
而接下來是 tutte 的精華</code></pre><hr>
<h2 id="sufficiency（充份性）"><a class="header-link" href="#sufficiency（充份性）"></a>Sufficiency（充份性）</h2>
<ul class="list">
<li>這邊是從後面性質證回來，也就是說明擁有 <code>o(G-S) &lt;= |S|</code> 性質的 graph，其必有 1-factor（perfact matching）的存在<ul class="list">
<li>== 假如 G 符合 Tutte&#39;s condition，則其有一 perfect matching (<code>1-factor</code>)</li>
</ul>
</li>
<li>而我們可以使用反證法（擁有 <code>o(G-S) &lt;= |S|</code> 性質，卻沒有 <code>1-factor</code>）來做證明，透過相同模型（分兩邊做討論），來分析各種情況，舉出擁有 <code>1-factor</code> 的實例，說明此假設錯誤，tutte&#39;s theorem 為真</li>
</ul>
<h3 id="先從假設的狀況下手"><a class="header-link" href="#先從假設的狀況下手"></a>先從假設的狀況下手</h3>
<ul class="list">
<li>首先我們設定 S 為<code>空集合</code>，這樣從<code>式(2)</code>中可以得到 <em>o(G-S) = o(G) ≤ |S| = 0</em>，所以從<code>式(1)</code>當中可以知道 <code>n(G)</code> 是 even<pre class="hljs"><code>  o(G-∅) = o(G) = <span class="hljs-number">0</span>, 表示沒有奇數 component!
  而此代表，graph G 的中 vertex 數量必定為 even !</code></pre></li>
</ul>
<h3 id="claim-1"><a class="header-link" href="#claim-1"></a>Claim 1</h3>
<p>增加一條 edge 並<code>維持 Tutte Condition</code>，也就是說，假設 e ∈ E(H)，而 H - e 符合 Tutte Condition（ 這個 H 就是加完 edge 並符合 Tutte Condition 的結果 ）</p>
<ul class="list">
<li><p>如何證明？</p>
<ul class="list">
<li>我們可以先預設認為 <code>H - e</code> 符合 Tutte Condition</li>
<li>而現在找一個 S，S ⊆ V (H)，屬於 H 的 vertex 集合</li>
<li>當 e 的其中一個 endpoint 在 S 之中時，則 <code>H - S = H - e - S</code> ，這麼一來，便可以知道： <pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">o</span><span class="hljs-params">(H - S)</span> = <span class="hljs-title">o</span><span class="hljs-params">(H - e - S)</span> ≤ |S|</span></code></pre></li>
<li><p>否則，假設 J, J&#39; 為 <code>H - e - S</code> 中的 Component，其內包含了 e 的 endpoint； 則可知其性質可分為以下幾種：</p>
<p class="img-container"><img src="../../../res/ch3/g-tutte-J.png" alt=""></p>
</li>
<li><p>而這幾種 case 都符合 <code>o(H - S) ≤ o(H - e - S) ≤ |S|</code>，則證明了 <em>Claim 1</em> 的假設符合 Tutte Condition</p>
</li>
</ul>
</li>
<li>因此，假設 1-factor 的存在性並不足以使 graph 擁有 Tutte Condition 的話，則我們可以選擇一個 <code>Maximal counterexample G</code>，使這個 G 擁有幾項特性：   <ul class="list">
<li>G 符合 Tutte Condition</li>
<li>但 G 沒有 1-factor</li>
<li>並且加入任何 single edge 進入 G <code>便可以產生一個 1-factor 的 graph</code> （也就是目前的 G 是達飽和狀態前的 graph） </li>
</ul>
</li>
</ul>
<h3 id="claim-2"><a class="header-link" href="#claim-2"></a>Claim 2</h3>
<p>有了以上的認知後，我們可以接下來做；使用多個狀態來展示矛盾狀況即可證明。</p>
<ul class="list">
<li>Idea:<ul class="list">
<li>使用了 U 這個集合，並且我們把重點放在<em>分析 G - U</em>這個部份</li>
<li>U 的性質<ul class="list">
<li>其內每個 vertex 的 degree 階為 n-1 (除了自己之外，對 graph G 內的每個 vertex 都有 edge 連通)<pre class="hljs"><code>U =  {v ∈ V | <span class="hljs-built_in">N</span>(<span class="hljs-comment">v</span>) = V − {v} = {v ∈ V | dG(v) = <span class="hljs-built_in">n</span> − <span class="hljs-number">1</span>}.
<span class="hljs-built_in">N</span>(<span class="hljs-comment">v</span>) 為 v 的 neighbor 集合，可以看到其集合為整個 Vertex Set，除自己以外的所有其他 vertex</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>有了以上的認知後，我們可以<code>針對 G-U ，來先分為兩個情況下去做討論</code></li>
</ul>
<h4 id="case-1"><a class="header-link" href="#case-1"></a>Case 1</h4>
<p><code>G-U</code> 是為互不相連的 cliques（complete graph） 組成，如下圖所示：</p>
<p class="img-container"><img src="../../../res/ch3/g-tutte-case1.png" alt=""></p>
<ul class="list">
<li>而灰色的點則為 U，在圖中不畫出這些 U 內 vertex 的 edge</li>
<li>計算 o(G-U) = 4<ul class="list">
<li>在圖中，有兩個 isolated vertices、一個 3-clique 以及一個 7-clique</li>
</ul>
</li>
<li><p>|U| = 8 </p>
<ul class="list">
<li>透過 Tutte condition 以及 <code>式(1)</code>，U 擁有相同的性質： 大於等於 o(G-U)</li>
</ul>
</li>
<li><p>接著可以建立 G-U 的 Maximum matching <em>M</em> (下圖中的紅色 edge)，試圖感染所有 G-U 的 components 中所有的 vertices</p>
<ul class="list">
<li>odd component 中的情況會是<code>必有一個 vertex 無法被 matching 所感染</code></li>
<li>而 even component 則是完美的感染完畢</li>
</ul>
</li>
</ul>
<p class="img-container"><img src="../../../res/ch3/g-tutte-case1-red.png" alt=""></p>
<ul class="list">
<li>接下來便是繼續加大這個 matching，以達到 graph G 的 perfect matching <em>M&#39;</em><ul class="list">
<li>剛剛的步驟後，剩餘未被感染的 vertex 都在 odd components 當中</li>
<li>所以我們可以透過讓這些 <em>未被感染者</em>，與 U 內的 vertex 建立 edge，來完成感染（下圖中綠色的部份）</li>
</ul>
</li>
</ul>
<p class="img-container"><img src="../../../res/ch3/g-tutte-case1-green.png" alt=""></p>
<ul class="list">
<li><p>到此為止，graph 當中沒有 matched 的 vertices 數量為 <code>|U| - o(G-U)</code> </p>
<ul class="list">
<li>這些 vertices 都屬於 U，並且以 U 的性質來看，他們都是<code>成對、並且相鄰的（其 degree 為所有 vertex 數量減 1）</code></li>
<li><p>而這些 vertices 數量為偶數；</p>
<pre class="hljs"><code>
為何為偶數？
Ans: 因為可以從前面得知，目前 graph 的組成使用到了：
(<span class="hljs-number">1</span>) 偶數的 <span class="hljs-built_in">components</span> -&gt; 提供 <span class="hljs-built_in">even</span> number 的 <span class="hljs-built_in">vertices</span>
(<span class="hljs-number">2</span>) 奇數的 <span class="hljs-built_in">components</span> -&gt; 提供 <span class="hljs-built_in">odd</span> number 的 <span class="hljs-built_in">vertices</span>
(<span class="hljs-number">3</span>) 而 U 內與奇數 <span class="hljs-built_in">components</span> 相連使用的 <span class="hljs-built_in">vertices</span> -&gt; <span class="hljs-built_in">odd</span>
而在一開始假設那段，我們可以知道再情況下， graph 的 vertice 總數量為 <span class="hljs-built_in">even</span> ！
那麼從上面可知，<span class="hljs-built_in">even</span>（總數）- <span class="hljs-built_in">even</span>（偶數 comp.）- <span class="hljs-built_in">odd</span>（奇數 comp.） - <span class="hljs-built_in">odd</span>（U 內對應的 <span class="hljs-built_in">vertices</span>）後的結果，必為偶數！(U 內剩餘的 <span class="hljs-built_in">vertices</span>)</code></pre></li>
<li><p>由於剩餘的互相為 pairwise adjacent vertices，這些 vertice 可以自行形成 perfect matching (下圖中藍色部份)</p>
</li>
</ul>
</li>
</ul>
<p class="img-container"><img src="../../../res/ch3/g-tutte-case1-blue.png" alt=""></p>
<p>這麼一來，Case 1 的狀態便分析完畢</p>
<h4 id="case-2"><a class="header-link" href="#case-2"></a>Case 2</h4>
<p><code>G-U</code> 並非互不相連的 cliques（complete graph）的情形。如下圖：</p>
<p class="img-container"><img src="../../../res/ch3/g-tutte-case2.png" alt=""></p>
<ul class="list">
<li><p>設 H 為其中一個 <code>G-U</code> 中的 component，並且不為 clique.</p>
<ul class="list">
<li>其至少有 3 個 vertices，其中兩個之間的距離必為 2（因為其不為 clique 的緣故）；比如上圖中 H 內的 <code>x</code>, <code>z</code></li>
<li>而 <code>x</code>, <code>z</code> 中有一個相同的鄰居 <code>y</code></li>
<li>並且存在一個 <code>w</code>，其屬於 G-U 的 vertex set 當中，並且 wy 之間的 edge 並不存在<pre class="hljs"><code>注意：
w 可能不一定屬於 <span class="hljs-built_in">H</span></code></pre></li>
<li>相同地，灰色的 vertices 表示 U 集合，每個 vertex 的 edge 都忽略不畫上去（影響重點）</li>
</ul>
</li>
<li><p>回到 G 的部份，當加入一個 single edge 進 G 後，則會產生一個 perfect matching； 根據此，我們假設了兩個 matching - <code>M1(藍色) = G + xz</code> 以及 <code>M2(紅色) = G + wy</code>，如下圖所示：</p>
</li>
</ul>
<p class="img-container"><img src="../../../res/ch3/g-tutte-case2-m1m2.png" alt=""></p>
<ul class="list">
<li>當中，虛線的 xz, wy 並不屬於 G</li>
<li>設 F = M1 及 M2 的 symmetric difference；而 xz,wy 則屬於 F <ul class="list">
<li>透過先前的 Lemma 所知， F 內的 component 為一條 <code>path</code> 或是 <code>even cycle</code></li>
<li>而實際上，當 F 內 component 是為 path 時，表示這些都是 isolated 的 vertex；否則其 endpoints 就不會被 M1 或是 M2 所感染</li>
</ul>
</li>
<li>以上圖看，則 component C 是為包含 xz 的 even cycle</li>
</ul>
<p>而針對這個 component C 再下去做分析，則可以再分為兩個 case 做討論：</p>
<h5 id="case-2a"><a class="header-link" href="#case-2a"></a>Case 2A</h5>
<p>yw 不屬於 C 時，則 M1 與 C 取 symmetric difference 的結果等於 <code>M2 與 E（C）取交集</code> 再與 <code>M1 扣除 E（C）後的結果</code>做<em>聯集</em>，其結果為一 perfect matching 且不包含 xz 或是 wy，合法屬於 G 的 perfect matching</p>
<h5 id="case-2b"><a class="header-link" href="#case-2b"></a>Case 2B</h5>
<p>yw 屬於 C，則我們可以稍微改一下上面圖，並標示出每個屬於 C 的 vertex: w,y,a1,a2,...,a<code>p</code>,z,x,b1,b2,...,b<code>q</code></p>
<ul class="list">
<li><p>其中上面的 p, q 皆為 odd</p>
<ul class="list">
<li>因為 path y,a1,...ap,z 這段上面， M1 及 M2 必須有相同數目的 edges</li>
<li>因此 edge 數目為 even，vertex 數量則為 odd</li>
<li>又 <code>|V(C)| = 4 + p + q</code>， 為 even !</li>
<li>所以 p, q 相同都為 odd</li>
</ul>
</li>
<li><p>所以 edge 集合為 M*</p>
<ul class="list">
<li>M* = {a1a2, ... , a(p-2)a(p-1), a(p)z, yx, b1b2, ... b(q-2)b(q-1), bqw} ，都屬於 E 集合（edge 總集合）</li>
<li>於下圖中<code>綠色</code>部份展示為一組 perfect matching 於 V(C) </li>
<li>下圖中<code>黃色</code>部份是展示 M1 - E(C) 為一組 perfect matching 於 V - V(C)</li>
<li>而這兩組取聯集後，成為 G 的一組 perfect matching ！ 因此符合 Tutte Condition !</li>
</ul>
</li>
</ul>
<p class="img-container"><img src="../../../res/ch3/g-tutte-case2-caseAB.png" alt=""></p>
<p>如此我們便可以說，在符合 tutte condition 情況下，其必定有 1-factor 的存在</p>
<h1 id="reference"><a class="header-link" href="#reference"></a>Reference</h1>
<ul class="list">
<li><a href="http://ion.uwinnipeg.ca/~ychen2/advancedAD/notes-March15.pdf">notes-March15.pdf</a></li>
</ul>
</body>
</html>
